\subsection{Problema a resolver}
El siguiente ejercicio consiste en escribir un algoritmo capaz de devolver, dado un conjunto de intervalos, el subconjunto máximo de los que no se solapan. Luego, el algoritmo debe poder tomar las fechas ofrecidas por los profesores del programa de Profesores Visitantes de la FCEyN para sus cursos e indicar qué cursos deberían elegirse para maximizar la cantidad de cursos en el ciclo. Cada intervalo corresponde a la fecha en que un profesor  dictará su curso. El primer elemento del intervalo corresponde a la fecha de inicio y el segundo a la fecha de fin. Para la simplificación del manejo de los datos, éstos se representan con números enteros positivos.\newline
\newline
\textbf {Formatos de entrada y salida:}\newline
\newline
La entrada contiene varias instancias del problema. Cada instancia consta de una línea con el siguiente formato:

$$n\ i_{1}\ f_{1}\ i_{2}\ f_{2}\ ...\ i_{n}\ f_{n}$$


donde \textbf{$n$} es la cantidad de cursos ofrecidos por los profesores (numerados de 1 a n) y los valores \textbf{$[i_{1},f_{1}],\ ...,\ [i_{n},f_{n}]$} representan los días de inicio y fin de cada uno de los n cursos. Todos los datos son enteros positivos. La entrada concluye con una línea comenzada por \# que no debe ser procesada.\newline

La salida debe contener una línea por cada instancia de entrada, donde se listan los números de los cursos elegidos para el ciclo de cursos.\newline
\newline
En lo que sigue, presentaremos dos ejemplos sobre cómo debería comportarse nuestro algoritmo:

{\large{\textbf{Ejemplos:}}}\newline

\begin{figure}[H] %[h] Aqui [b] para button [t] para top
\begin{center}
\includegraphics[width=450pt]{../imgs/ejemplosej2.jpg}
\end{center}
\end{figure}

\subsection{Resolución coloquial}

O1: Los dias de inicio son menores a los dias de finalizacion de cada curso\\

Sea $v$ un intervalo, este intervalo está representado por dos valores: $v_{i}$ es el inicio del intervalo y $v_{f}$ es el fin del intervalo. Sea C un conjunto de intervalos.\\

El modelo de nuestro problema mapea a los cursos como intervalos, donde el dia de incio es el valor $v_{i}$ y el dia de finalizacion del curso es $v_{f}$, la solucion se obtiene encontrando un conjunto maximo de elementos cuyos intervalos no se solapen, esto significa: 

\par{$$\forall v1, v2 \in C\ |\ (v1_{f} < v2_{i}) \vee (v2_{f} < v1_{i})$$} 

esta es condición suficiente ya que por O1 el valor de incio de un curso es menor al valor de fin del mismo curso para todos los cursos.

\subsection{Demostración de correctitud}

Veamos que efectivamente nuestro algoritmo encuentra una solución óptima. 

Sea $S$ una solución optima de problema. supongamos por el absurdo que no lo es, entonces existe una solución $S'$ que tiene una cantidad de intervalos mayor que $S$.\\ Si los intervalos de $S' - S$ no se solapan con ningún intervalo de $S$ entonces el algoritmo los úbiera seleccionado, ya que siempre toma todos los intervalos que no están solapados con los que ya tomó y llegamos a un absurdo, que provino de suponer que hay una mejor solucion.

\par{En el caso en que los intervalos $S' - S$ se solapen con intervalos de $S$ debe existir al menos $n-1$ intervalo dentro de $S$ que pueda ser reemplazado por $n$ o más intervalos que esten en $S'$. llamemos $V$ a estos intervalos y $W$ al conjunto de intervalos por el que lo puedo intercambiar, notese que $#V < #W$ ya que si no fuera asi no podriamos decir que hay una mejor solucion, Entonces por la formula que vimos, debe existir un intervalo $w \in W$ tal que para algún intervalo de $v \in V$ se cumpla que $w_{f} > v_{i} \land v_{f} > w_{i}$ lo cual quiere decir que el fin de ese intervalo $w$ está antes que el fin del intervalo $v$, pero si esto fuera asi, entonces el algoritmo úbiera seleccionado primero el intervalo $w$ ya que siempre toma los intervalos que terminan antes de los que ya seleccionó, con lo cual llegamos a un absurdo, que provino de suponer que existia una mejor solucion.}

% Primero veamos el invariante de nuesta solucion:
% \begin{itemize}
% \item Sea S una solucion, cumple que el i-esimo curso tiene la fecha de finalizacion mas proxima posible\footnote{Con "posible" nos referimos a que no se solapa con ningun curso que tenga menor fecha de finalizacion.} al anterior, es decir, al (i-1)-esimo curso. Estando siempre el curso que primero finaliza como solucion.
% \end{itemize}

% Sea C un conjunto de cursos tal que:
% \begin{itemize}
% \item Ningun curso se solapa, la solucion es C. Esto es trivial, ya que mas cursos de los que hay no pueden  haber.
% \item Existen dos cursos que se solapan. Sea $i$ y $j$ dichos cursos. Sin perder generalidad supongamos que la fecha de terminacion de $j$ es mayor o igual que la de $i$. Quiero ver que, si S es la solucion que contiene a $i$ y S' es la solucion que contiene a $j$ $\Rightarrow$ $|$S'$|$ $\leq$ $|$S$|$. 
%   Esto se cumple porque S' contiene a $j$ que termina luego que $i$, por lo que por lo menos todos los cursos de S' desde el $j$ estan contenidos en S y, ademas, si  $j$ comienza antes que $i$ se que la cantidad de cursos de S' antes de $j$ estan antes de $i$ en S 

% \begin{figure}[H] %[h] Aqui [b] para button [t] para top
% \begin{center}
% \includegraphics[width=322pt]{../imgs/demo21.jpg}
% \end{center}
% \end{figure}

% o si $j$ empieza luego de $i$ yo se que no termina ningun otro curso entre el comienzo de $i$ y $j$, porque de terminar ubiese elejido ese en S  (ya que elijo siempre el que termina antes), 

% \begin{figure}[H] %[h] Aqui [b] para button [t] para top
% \begin{center}
% \includegraphics[width=322pt]{../imgs/demo22.jpg}
% \end{center}
% \end{figure}

% \end{itemize}

% por lo tanto, $|$S'$| \leq |$S$|$. 


\subsection{Complejidad del algoritmo}

Sea $n$ la cantidad de cursos. La complejidad de nuestro algoritmo es $\mathcal{O}(n\ log\ n)$, antes de ver el porque de esto tengamos en cuenta algunos aspectos:
\begin{enumerate}
\item La complejidad del algoritmo \textbf{Sort} es $\mathcal{O}(n\ log\ n)$\footnote{http://en.cppreference.com/w/cpp/algorithm/sort}.
\item La complejidad del \textbf{constructor} que utilizamos sobre la estructura \textbf{vector} es $\mathcal{O}(1)$\footnote{http://en.cppreference.com/w/cpp/container/vector/vector}.
\item La complejidad del \textbf{reserve} que utilizamos sobre la estructura \textbf{vector} es $\mathcal{O}(n)$\footnote{http://en.cppreference.com/w/cpp/container/vector/reserve}.
\item La complejidad del algoritmo \textbf{push$\_$back} sobre la estructura \textbf{vector} es O(1) amortizado pero cuando se ultiliza previamente la funcion $reserve(n)$ agregar los primeros n elementos es O(1)\footnote{http://en.cppreference.com/w/cpp/container/vector/push$\_$back}. 
\item La complejidad del algoritmo \textbf{size} sobre la estructura \textbf{vector} es O(1)\footnote{http://en.cppreference.com/w/cpp/container/vector/size}.
\item La complejidad de la funcion \textbf{filtrarSolapamientos} es $\mathcal{O}(n)$ ya que va recorriendo los cursos, comparando y agregando elementos segun corresponda (comparar es constante al igual que agregar y recorrer lineal), en otras palabras, se encuentra un \textbf{if} (complejidad constante) y un \textbf{push$\_$back} (complejidad constante) dentro de un \textbf{for} (complejidad lineal). 
\end{enumerate}
Teniendo en cuenta lo anterior el siguiente grafico muestra el codigo y al costado la complejidad de cada operacion.

\begin{figure}[H] %[h] Aqui [b] para button [t] para top
\begin{center}
\includegraphics[]{../imgs/comple2.jpg}
\end{center}
\end{figure}

Finalmente, la complejidad es: $\mathcal{O}(1)+\mathcal{O}(n)+\mathcal{O}(n\ log\ n)+\mathcal{O}(n)+\mathcal{O}(1)+\mathcal{O}(n)*\mathcal{O}(1)*\mathcal{O}(1)$ = \textbf{\mathcal{O}(n\ log\ n)}

\subsection{Código fuente}



\subsection{Instancias posibles}



\subsection{Testing}
